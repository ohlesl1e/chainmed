const Application = artifacts.require("Chaindoser");
const Manager = artifacts.require("Manager");
const Doctor = artifacts.require("Doctor");
const axios = require('axios')
const mysql = require('mysql2')
const fs = require('fs');
const { Parser } = require('json2csv');
require('dotenv').config()
const envfile = require('envfile')

const connection = mysql.createConnection({
    host: 'localhost',
    user: 'root',
    password: process.env.DB_PASS,
    database: 'mydb',
})

const paths = ['./.env', './chaindoser/.env', './chaindoser/.env.production', './manager/.env']

const scheduleUnit = ['d', 'w', 'M']
const genders = ['male', 'female', 'non-binary']
const foodAllergy = [
    "Balsam of Peru",
    "Buckwheat",
    "Celery",
    "Egg",
    "Fish",
    "Fruit",
    "Garlic",
    "Oats",
    "Maize",
    "Milk",
    "Mustard",
    "Peanut",
    "Poultry Meat",
    "Rice",
    "Sesame",
    "Shellfish",
    "Tartrazine",
    "Tree nut",
    "Wheat",
];
const medAllergy = [
    "Tetracycline",
    "Dilantin",
    "Tegretol",
    "Penicillin",
    "Cephalosporins",
    "Sulfonamides",
    "Non-steroidal anti-inflammatories",
    "Intravenous contrast dye",
    "Local anesthetics",
];

const usd = 1300
let previousTimestamp = Math.floor(new Date().getTime() / 1000)

const compareArrays = (a, b) => {
    return JSON.stringify(a) === JSON.stringify(b);
};

const getTransaction = async (type, transactionHash) => {
    let trx = await web3.eth.getTransaction(transactionHash)
    let trxReceipt = await web3.eth.getTransactionReceipt(transactionHash)
    let block = await web3.eth.getBlock(trx.blockNumber)
    let gasUsed = trxReceipt.gasUsed * trx.gasPrice;
    let res = {
        'type': type,
        'gasUsed': trxReceipt.gasUsed,
        'gasPrice': web3.utils.fromWei(trx.gasPrice, 'gwei'),
        '1ETH*USD': usd,
        'gasUsed*gasPrice(Ether)': web3.utils.fromWei(gasUsed.toString(), 'ether'),
        'gasUsed*gasPrice(USD)': web3.utils.fromWei(gasUsed.toString(), 'ether') * usd,
        'time(s)': block.timestamp - previousTimestamp
    }
    previousTimestamp = block.timestamp
    // console.log({ trx, trxReceipt, block });
    return res
}

const exportTransaction = (transactions, filename) => {
    // console.log(transactions);
    const output = new Parser({
        fields: ['type',
            'gasUsed',
            'gasPrice',
            '1ETH*USD',
            'gasUsed*gasPrice(Ether)',
            'gasUsed*gasPrice(USD)',
            'time(s)'],
        header: true
    }).parse(transactions)
    fs.writeFileSync(`./log/${filename}.csv`, output)
}

const isValidNonZeroAddress = (address) => {
    if (web3.utils.isAddress(address)) {
        return parseInt(address, 16) !== 0
    }
    return false
}

const getRandomUint = (min, max) => {
    min = Math.ceil(min)
    max = Math.floor(max)
    return Math.floor(Math.random() * (max - min) + min)
}

const timeout = ms => new Promise(resolve => setTimeout(resolve, ms))

const getInfo = async () => {
    const res = (await axios.get('https://api.api-ninjas.com/v1/randomuser', {
        headers: { 'X-Api-Key': '64+omSqijRq2AO8iwDwaoA==VN9F5JioJSciClcN' }
    })).data
    return {
        name: web3.utils.padRight(web3.utils.asciiToHex(res.name), 64),
        gender: web3.utils.padRight(web3.utils.asciiToHex(genders[getRandomUint(0, 3)]), 64),
        dob: new Date(res.birthday),
        height: getRandomUint(150, 200),
        weight: getRandomUint(5000, 10000),
        allergy: [],
        alcohol: getRandomUint(0, 2) === 1 ? true : false,
        smoke: getRandomUint(0, 2) === 1 ? true : false,
        cannabis: getRandomUint(0, 2) === 1 ? true : false
    }
}

/*
 * uncomment accounts to access the test accounts made available by the
 * Ethereum client
 * See docs: https://www.trufflesuite.com/docs/truffle/testing/writing-tests-in-javascript
 */
contract("Application", async (accounts) => {
    console.log(accounts);

    it("should assert true", async () => {
        // const application = await Application.at(process.env.PUBLIC_APPLICATION_ADDRESS);
        // const manager = await Manager.at(process.env.PUBLIC_MANAGER_ADDRESS)
        const application = await Application.deployed();
        const manager = await Manager.deployed()
        console.log({
            application: application.address,
            manager: manager.address
        });

        for (const path of paths) {
            fs.readFile(path, 'utf-8', (err, data) => {
                if (err) {
                    console.log(err);
                    return
                }

                const parsedFile = envfile.parse(data)
                parsedFile['PUBLIC_APPLICATION_ADDRESS'] = application.address
                parsedFile['PUBLIC_MANAGER_ADDRESS'] = manager.address

                fs.writeFileSync(path, envfile.stringify(parsedFile))

                // console.log(parsedFile);
            })
        }



        return assert.isTrue(true);
    });

    it('should add 2 doctors', async () => {
        // const application = await Application.at(process.env.PUBLIC_APPLICATION_ADDRESS);
        // const manager = await Manager.at(process.env.PUBLIC_MANAGER_ADDRESS)
        const application = await Application.deployed();
        const manager = await Manager.deployed()
        const transactions = []


        const doc1 = manager.addDoctor(accounts[accounts.length - 1], web3.utils.toHex('Dolores Haze'), web3.utils.toHex('Kaiser Permanente'), { from: accounts[0] })
        const doc2 = manager.addDoctor(accounts[accounts.length - 2], web3.utils.toHex('Jonah Vogelbaum'), web3.utils.toHex('Vought International'), { from: accounts[0] })

        transactions.push(await getTransaction('add doctor', (await doc1).tx))
        transactions.push(await getTransaction('add doctor', (await doc2).tx))

        const prof1 = await manager.getDoctor(accounts[accounts.length - 1])
        const prof2 = await manager.getDoctor(accounts[accounts.length - 2])

        console.log({ doc1: prof1, doc2: prof2 })

        const d1 = await Doctor.at(prof1)
        const d2 = await Doctor.at(prof2)

        const MANAGER_ROLE = await d1.MANAGER_ROLE()
        const DOCTOR_ROLE = await d1.DOCTOR_ROLE()
        console.log({ MANAGER_ROLE, DOCTOR_ROLE });

        const roleCheck1 = await d1.hasRole(DOCTOR_ROLE, accounts[accounts.length - 1], { from: accounts[accounts.length - 1] })
        const roleCheck2 = await d2.hasRole(DOCTOR_ROLE, accounts[accounts.length - 2], { from: accounts[accounts.length - 2] })

        console.log({ roleCheck1, roleCheck2 });


        const grant1 = await d1.grantRole(MANAGER_ROLE, application.address, { from: accounts[accounts.length - 1] })
        const grant2 = await d2.grantRole(MANAGER_ROLE, application.address, { from: accounts[accounts.length - 2] })

        // exportTransaction(transactions, 'addDoctor')

        return assert.isTrue(isValidNonZeroAddress(prof1) && isValidNonZeroAddress(prof2))
    })

});
